#+TITLE: GoCard Project Issues
#+AUTHOR: David Miserak
#+DATE: 2025-03-21
#+PROPERTY: priority (A B C)
#+PROPERTY: status "TODO" "IN-PROGRESS" "REVIEW" "DONE"
#+PROPERTY: effort_estimate 1:00 2:00 4:00 8:00 16:00 24:00 40:00
#+COLUMNS: %25ITEM %TODO %PRIORITY %TAGS %EFFORT

* Core Functionality [4/4]
** DONE [#A] Issue 1: File-Based Storage Implementation
:PROPERTIES:
:EFFORT:   16:00
:END:

*** User Story
As a user who values text-based workflows,
I need a system that stores flashcards as Markdown files in regular directories
So that I can easily edit, track, and back up my knowledge base with standard tools.

*** Details and Assumptions
- Each card should be stored as a single Markdown file
- Files should follow the specified format with YAML frontmatter and Question/Answer sections
- Directory structure should represent deck hierarchy
- Changes to files should be reflected in the application

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given the application is running
When I create a new card through the application
Then a properly formatted Markdown file should be created in the specified directory

Given a properly formatted Markdown file exists in the watched directory
When I launch the application
Then the card should be loaded and available for review

Given I make changes to a card file using an external text editor
When the application is running or restarted
Then those changes should be reflected in the card's content
#+END_SRC

*** Implementation Notes
- Create Card struct with required fields
- Implement file reading/writing functions
- Support YAML frontmatter parsing
- Add basic markdown parsing
- Create file path handling utilities

*** Related Issues
None

** DONE [#A] Issue 2: Implement SM-2 Spaced Repetition Algorithm
:PROPERTIES:
:EFFORT:   8:00
:END:

*** User Story
As a learner,
I need an efficient spaced repetition system
So that I can optimize my memory retention and learning efficiency.

*** Details and Assumptions
- Implement the SM-2 algorithm similar to Anki
- Track review intervals, last review date, and difficulty in file metadata
- Support 0-5 rating system for card difficulty
- Calculate next review date based on performance

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given I am reviewing a card
When I rate it with a difficulty score of 0-5
Then the review interval should be calculated according to SM-2 algorithm

Given a card has been reviewed previously
When I open the application on a future date
Then I should only see cards that are due for review

Given I review a card successfully multiple times
When I continue using the application
Then the interval between reviews should increase appropriately
#+END_SRC

*** Implementation Notes
- Research SM-2 algorithm implementation details
- Add interval calculation functions
- Integrate with card metadata
- Add review history tracking

*** Related Issues
- Issue 1: File-Based Storage Implementation

** DONE [#A] Issue 14: Implement Real-time File Watching with fsnotify
:PROPERTIES:
:EFFORT:   8:00
:END:

*** User Story
As a user who edits flashcards with external text editors,
I need GoCard to automatically detect and reload cards when they change on disk
So that I can seamlessly work with my preferred editor and see changes immediately in the application.

*** Details and Assumptions
- Users may edit, create, or delete card files outside the application
- We need to monitor the entire directory tree recursively
- Changes should be detected in near real-time
- The application needs to handle various file events:
  - Creation of new card files
  - Modification of existing card files
  - Deletion of card files
  - File renaming
  - Moving files between directories
- The current implementation has a placeholder for file watching that needs to be implemented

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given I have GoCard running
When I create a new markdown file in the watched directory using an external editor
Then the application should detect the new file and add it to the card collection

Given I have GoCard running
When I modify the content of an existing card file using an external editor
Then the application should detect the change and update the card in memory

Given I have GoCard running
When I delete a card file using an external text editor or file manager
Then the application should detect the deletion and remove the card from memory

Given I have GoCard running
When I rename a card file using an external application
Then the application should handle this correctly by removing the old card and adding the new one

Given I have multiple levels of subdirectories
When I add, modify, or delete files in any subdirectory
Then the application should correctly detect and handle these changes
#+END_SRC

*** Implementation Notes
- Use the fsnotify package to watch for file system events
- Implement recursive directory watching (fsnotify only watches a single directory by default)
- Add debouncing to prevent duplicate events (files being saved may trigger multiple events)
- Handle edge cases like:
  - Files being edited while the application is loading
  - Temporary files created by text editors
  - Moving files between watched directories
- Ensure efficient processing of file events to avoid performance issues
- Consider adding a configuration option to enable/disable file watching

*** Related Issues
- Issue 1: File-Based Storage Implementation

** DONE [#A] Issue 15: Implement Deck Organization through Directory Structure
:PROPERTIES:
:EFFORT:   16:00
:END:

*** User Story
As a GoCard user,
I need to organize my flashcards into logical groupings (decks) using directories
So that I can manage my learning materials by topic, difficulty, or other classification schemes.

*** Details and Assumptions
- Directories in the file system should represent decks in the application
- Subdirectories should represent sub-decks (nested organization)
- Users should be able to:
  - Create new decks (directories)
  - Move cards between decks
  - View cards by deck
  - Get statistics per deck
  - Filter review sessions by deck
- The directory structure is already partially supported in the file loading logic
- Need to add explicit deck management features to the application

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given I am using the application
When I create a new deck
Then a new directory should be created in the file system

Given I have multiple decks
When I select a specific deck
Then I should only see cards from that deck and its sub-decks

Given I am viewing a card
When I move it to a different deck
Then the card's file should be moved to the corresponding directory

Given a nested directory structure exists
When I load the application
Then the deck hierarchy should match the directory structure

Given I have cards in various decks
When I start a review session
Then I should be able to filter the session to specific decks

Given I have multiple decks
When I view statistics
Then I should be able to see statistics broken down by deck
#+END_SRC

*** Implementation Notes
- Extend the current CardStore to track deck information
- Add methods for creating, renaming, and deleting decks
- Implement deck selection and filtering in the UI
- Ensure moving cards between decks handles file operations correctly
- Make sure file paths are updated correctly when cards are moved
- Consider adding deck metadata (perhaps as a special .deck.md file in each directory)
- Implement proper error handling for file operations across directories
- Consider platform-specific path handling for cross-platform compatibility
- Add a visual representation of the deck hierarchy in the UI

*** Example Structures
Current:
#+BEGIN_SRC
CardStore
└── map[filepath]*Card
#+END_SRC

Proposed:
#+BEGIN_SRC
CardStore
├── map[filepath]*Card  // All cards
└── map[deckPath]*Deck  // Organized by deck

Deck
├── Name           // Deck name (directory name)
├── Path           // Directory path
├── Cards          // Cards directly in this deck
├── SubDecks       // Child decks
└── ParentDeck     // Parent deck (optional)
#+END_SRC

*** Related Issues
- Issue 1: File-Based Storage Implementation
- Issue 3: Basic Card Navigation and Review Interface
- Issue 6: Search and Filter Functionality
* Enhanced Features [4/5]
** DONE [#B] Issue 13: Convert to Goldmark for Markdown Processing
:PROPERTIES:
:EFFORT:   8:00
:END:

*** User Story
As a developer of GoCard,
I need to upgrade the markdown parsing to use the Goldmark library
So that we can properly render rich markdown content with consistent parsing and better extensibility.

*** Details and Assumptions
- The current implementation uses a basic string-splitting approach for parsing markdown
- Goldmark is mentioned in the README as the intended markdown renderer
- Features needed:
  - Full markdown syntax support (tables, code blocks, etc.)
  - Support for syntax highlighting via Chroma integration
  - Extension capability for custom card formatting
  - Proper handling of markdown edge cases
- We need to maintain the YAML frontmatter handling separate from markdown content

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given a markdown file with complex formatting
When the file is loaded by the application
Then all markdown elements should be correctly parsed and represented in the Card struct

Given a card with rich markdown content in the question or answer
When the card is saved to disk
Then the markdown should be properly preserved in the output file

Given a card with code blocks using different programming languages
When the card is rendered
Then the code should maintain proper formatting and be ready for syntax highlighting

Given markdown content with special characters or edge cases
When the content is parsed
Then the parser should handle these cases correctly without data loss
#+END_SRC

*** Implementation Notes
- Use Goldmark as the markdown parser
- Separate the YAML frontmatter parsing from the markdown content parsing
- Consider using the Goldmark YAML frontmatter extension
- Integrate with Chroma for syntax highlighting as described in the README
- Update tests to verify proper parsing of complex markdown elements

*** Related Issues
- Issue 1: File-Based Storage Implementation
- Issue 4: Markdown Rendering with Code Syntax Highlighting

** DONE [#B] Issue 3: Basic Card Navigation and Review Interface
:PROPERTIES:
:EFFORT:   24:00
:END:

*** User Story
As a user,
I need a simple interface to navigate and review my flashcards
So that I can focus on learning without distractions.

*** Details and Assumptions
- Show question first, then reveal answer on command
- Support core keyboard shortcuts (space, 0-5, n, e, d, q)
- Display card metadata and progress information
- Provide simple navigation between due cards

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given I am viewing a question
When I press space
Then the answer should be revealed

Given I am viewing a card's answer
When I press a number from 0-5
Then the card should be rated and I should move to the next due card

Given there are multiple due cards
When I complete a review session
Then I should see a summary of my progress
#+END_SRC

*** Implementation Notes
- Use Fyne GUI toolkit for Go as mentioned in README
- Implement keyboard shortcut handling
- Create simple card display UI
- Add progress tracking for review sessions
- Create session summary view

*** Related Issues
- Issue 1: File-Based Storage Implementation
- Issue 2: Implement SM-2 Spaced Repetition Algorithm

** DONE [#B] Issue 4: Markdown Rendering with Code Syntax Highlighting
:PROPERTIES:
:EFFORT:   16:00
:END:

*** User Story
As a developer using flashcards for programming concepts,
I need proper rendering of markdown with syntax highlighting for code blocks
So that I can effectively learn programming-related content.

*** Details and Assumptions
- Support full Markdown rendering
- Implement syntax highlighting for 50+ programming languages
- Ensure code blocks are properly formatted and readable
- Support for common programming markdown extensions
- Code blocks should be visually distinct from regular text
- Display line numbers for longer code blocks
- Handling of inline code vs. block code should be consistent

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given a card contains a code block with language specification
When the card is displayed
Then the code should be rendered with appropriate syntax highlighting

Given a card contains various markdown elements (lists, tables, etc.)
When the card is displayed
Then all elements should be properly rendered according to markdown specifications

Given a code block has a specific language specified
When the card is rendered
Then the syntax highlighting should match that language's conventions

Given code examples of varying complexity
When rendered in the application
Then they should maintain proper indentation and formatting
#+END_SRC

*** Implementation Notes
- Integrate Goldmark for markdown parsing
- Use Chroma for syntax highlighting as mentioned in README
- Create custom styling for code blocks
- Support at least the following languages: Go, Python, JavaScript, Java, C/C++, SQL, HTML/CSS, Rust, Ruby
- Optimize rendering performance for cards with multiple code blocks
- Add configuration options for syntax highlighting themes
- Consider side-by-side diff view for comparing code (mentioned in README)

*** Related Issues
- Issue 1: File-Based Storage Implementation
- Issue 13: Convert to Goldmark for Markdown Processing

** DONE [#B] Issue 5: Card Creation and Editing Interface
:PROPERTIES:
:EFFORT:   16:00
:END:

*** User Story
As a user,
I need a built-in editor for creating and modifying cards
So that I can quickly add or update content without leaving the application.

*** Details and Assumptions

- Support creating new cards with a template
- Allow editing existing cards
- Provide markdown preview
- Auto-save changes to file system
- Support for setting and editing tags
*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given I am in the application
When I press 'n' to create a new card
Then I should see an editor with a template for the new card

Given I am viewing a card
When I press 'e' to edit
Then I should see an editor with the current card's content

Given I am editing a card
When I save the changes
Then the changes should be reflected in both the UI and the underlying file
#+END_SRC
** TODO [#B] Issue 6: Search and Filter Functionality
:PROPERTIES:
:EFFORT:   16:00
:END:

*** User Story
As a user with many flashcards,
I need to be able to search and filter my card collection
So that I can quickly find specific cards or focus on particular topics.

*** Details and Assumptions
- Search by card content, title, or tags
- Filter by deck/directory
- Filter by due date, creation date, or difficulty
- Support for combining search criteria

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given I have a collection of cards
When I enter a search term
Then only cards matching that term should be displayed

Given I have cards with various tags
When I filter by a specific tag
Then only cards with that tag should be shown

Given I have cards in different directories
When I select a specific directory
Then only cards from that directory should be displayed
#+END_SRC

*** Implementation Notes
- Implement text search functionality
- Add tag-based filtering
- Implement metadata-based filtering (due date, creation date, difficulty)
- Create UI components for search and filter controls
- Optimize search for large collections

*** Related Issues
- Issue 1: File-Based Storage Implementation
- Issue 4: Implement Deck Organization through Directory Structure

* Advanced Features [0/4]
** TODO [#C] Issue 7: Import/Export Compatibility
:PROPERTIES:
:EFFORT:   24:00
:END:

*** User Story
As a user with existing flashcard collections,
I need to import and export cards in common formats
So that I can migrate my knowledge base between different systems.

*** Details and Assumptions
- Support importing/exporting Anki packages (.apkg)
- Support plain text imports with common formats
- Preserve metadata when possible during import/export
- Handle batch operations for multiple cards

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given I have an Anki package file
When I import it into GoCard
Then the cards should be converted to Markdown files with appropriate metadata

Given I have a collection of GoCard markdown files
When I export them to an Anki package
Then the resulting file should be importable into Anki

Given I perform an import operation
When there are conflicts or format issues
Then I should receive clear error messages and options to resolve issues
#+END_SRC

*** Implementation Notes
- Research Anki package format
- Find or create Go libraries for handling .apkg files
- Implement mapping between Anki fields and GoCard format
- Add import/export UI
- Create conflict resolution handling

*** Related Issues
- Issue 1: File-Based Storage Implementation

** TODO [#C] Issue 8: Customizable Styling and Themes
:PROPERTIES:
:EFFORT:   8:00
:END:

*** User Story
As a user with specific visual preferences,
I need to be able to customize the application's appearance
So that I can create a comfortable learning environment.

*** Details and Assumptions
- Implement light and dark themes
- Allow customization of fonts, sizes, and colors
- Support for different code highlighting themes
- Store preferences in configuration file
- Provide sensible defaults for all customizable elements
- Support for high-contrast mode for accessibility
- Changes should apply immediately without requiring restart

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given I open the preferences dialog
When I select a different theme
Then the application's appearance should update accordingly

Given I modify font settings
When I view cards
Then the new font settings should be applied

Given I have set custom preferences
When I restart the application
Then my preferences should be preserved

Given I select a different code highlighting theme
When viewing a card with code blocks
Then the code should be highlighted according to the selected theme
#+END_SRC

*** Implementation Notes
- Create theme definition structure
- Implement theme switching mechanism
- Use CSS-like styling system for customization
- Add preferences UI with live preview
- Include at least 3 built-in themes (light, dark, high-contrast)
- Store theme configurations in the application config file
- Consider supporting custom CSS for advanced users
- Ensure all UI elements follow the theme consistently

*** Related Issues
- Issue 11: Configuration File Management
- Issue 4: Markdown Rendering with Code Syntax Highlighting

** TODO [#C] Issue 9: Code Testing Integration
:PROPERTIES:
:EFFORT:   24:00
:END:

*** User Story
As a developer learning programming concepts,
I need to be able to test code snippets directly from flashcards
So that I can verify my understanding through execution.

*** Details and Assumptions
- Support running code snippets in common languages
- Display execution results
- Handle basic input/output for testing
- Implement sandboxing for security
- Support for at least Python, JavaScript, and Go
- Allow for custom test cases
- Provide execution timeout to prevent infinite loops
- Show error messages in a user-friendly format

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given a card contains an executable code snippet
When I click "Run Code"
Then the code should execute and display the results

Given a code snippet requires input
When I run the code
Then I should be prompted for input values

Given a code snippet execution results in an error
When I run the code
Then I should see a clear error message explaining the issue

Given a code snippet is in a supported language
When I modify the code in the viewer
Then I should be able to run the modified version without changing the original card
#+END_SRC

*** Implementation Notes
- Research code execution options (local vs. remote execution)
- Implement language-specific execution environments
- Create secure sandboxing to prevent malicious code execution
- Add UI controls for code execution and input/output
- Consider using Docker containers for language isolation
- Implement caching of execution environments for better performance
- Add support for test cases that verify expected outputs
- Include execution statistics (runtime, memory usage)

*** Related Issues
- Issue 4: Markdown Rendering with Code Syntax Highlighting
- Issue 10: Cross-Platform Build Configuration

** TODO [#C] Issue 10: Cross-Platform Build Configuration
:PROPERTIES:
:EFFORT:   16:00
:END:

*** User Story
As a user on various operating systems,
I need GoCard to run seamlessly on my platform of choice
So that I can use it regardless of my operating system.

*** Details and Assumptions
- Support for Linux, macOS, and Windows
- Consistent user experience across platforms
- Appropriate installation methods for each OS
- Handle platform-specific file system differences
- Ensure keyboard shortcuts work consistently
- Address platform-specific UI rendering differences
- Package the application appropriately for each platform

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given development is complete
When building for Linux, macOS, and Windows
Then the application should compile and run without platform-specific bugs

Given installation instructions for each platform
When a user follows them
Then the application should install correctly and be ready to use

Given the application is running on different platforms
When performing the same actions
Then the behavior should be consistent across platforms

Given platform-specific conventions (e.g., keyboard shortcuts)
When using the application on that platform
Then the application should follow those conventions
#+END_SRC

*** Implementation Notes
- Set up cross-platform build pipeline
- Create OS-specific installation packages:
  - .deb/.rpm for Linux
  - .dmg/.pkg for macOS
  - .msi/.exe for Windows
- Use Fyne's cross-platform capabilities
- Implement file path handling that works across systems
- Test UI rendering on all target platforms
- Create platform-specific fallbacks where needed
- Document platform-specific considerations
- Consider CI/CD setup for automated cross-platform builds

*** Related Issues
- Issue 11: Configuration File Management

* Infrastructure [0/2]

** TODO [#B] Issue 11: Configuration File Management
:PROPERTIES:
:EFFORT:   8:00
:END:

*** User Story
As a user with specific preferences,
I need a well-documented configuration system
So that I can customize the application to my workflows.

*** Details and Assumptions
- Create ~/.gocard.yaml configuration file
- Document all available options
- Provide sensible defaults
- Validate configuration on load
- Support for multiple configuration profiles
- Allow command-line overrides of config options
- Include comments in default config file explaining options
- Handle configuration errors gracefully

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given a fresh installation
When I launch the application for the first time
Then a default configuration file should be created

Given I modify the configuration file
When I restart the application
Then my changes should be applied

Given I make an invalid change to the configuration
When I launch the application
Then I should receive a clear error message and fallback to defaults

Given I specify a config file location via command line
When I launch the application
Then it should use that config file instead of the default location
#+END_SRC

*** Implementation Notes
- Use YAML for configuration format
- Create configuration struct that maps to YAML structure
- Implement validation logic for all settings
- Add detailed comments in default configuration
- Create helper functions for common configuration tasks
- Support environment variable overrides
- Add command-line flags for configuration options
- Implement configuration reloading without restart (when possible)
- Create migration path for future config format changes

*** Related Issues
- Issue 8: Customizable Styling and Themes
* Testing [0/10]
** TODO [#A] Issue 32: Enhance Storage Layer Testing with Mock Filesystem
:PROPERTIES:
:EFFORT:   16:00
:END:

*** User Story
As a GoCard developer,
I need reliable tests for the storage layer that don't depend on the actual filesystem,
So that tests are deterministic, fast, and can cover error scenarios that are difficult to reproduce with real files.

*** Details and Assumptions
- Current tests depend on temporary directories on the real filesystem
- We need to mock file operations to test error handling
- File watching needs thorough testing with simulated events
- We should use a library like Afero for filesystem abstraction

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given the storage package
When tests are run
Then they should use a mock filesystem instead of the real filesystem

Given various error conditions (permission denied, disk full, etc.)
When file operations are performed
Then the code should handle these errors appropriately and the tests should verify this

Given file watching functionality
When filesystem events occur
Then the tests should verify that events are handled correctly

Given the test suite
When it is run on any system
Then it should not create or modify files outside of the test environment
#+END_SRC

*** Implementation Notes
- Use Afero for filesystem abstraction
- Create test helpers for common filesystem operations
- Implement comprehensive error injection
- Test concurrent file operations
- Ensure cleanup after tests

*** Related Issues
- Issue 1: File-Based Storage Implementation
- Issue 14: Implement Real-time File Watching with fsnotify

** TODO [#A] Issue 33: Expand Core Algorithm (SM-2) Test Coverage
:PROPERTIES:
:EFFORT:   8:00
:END:

*** User Story
As a GoCard developer,
I need comprehensive tests for the SM-2 algorithm implementation,
So that I can be confident it correctly schedules card reviews under all conditions.

*** Details and Assumptions
- SM-2 algorithm has basic tests but needs more coverage
- Edge cases (very short/long intervals) need testing
- Properties of the algorithm should be verified systematically
- Real-world learning patterns should be simulated

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given property-based tests for the SM-2 algorithm
When they are run
Then they should verify key properties like "intervals increase with higher ratings"

Given edge case tests
When a card has extreme values (0 interval, max difficulty, etc.)
Then the algorithm should handle these cases correctly

Given tests with realistic learning patterns
When simulating a user's learning over time
Then the algorithm should produce expected scheduling results

Given the SM-2 implementation
When subjected to fuzz testing
Then it should not crash or produce invalid results
#+END_SRC

*** Implementation Notes
- Implement property-based testing (consider go-quicktest)
- Add table-driven tests for edge cases
- Create test fixtures for realistic learning patterns
- Add benchmarks for performance-critical calculations

*** Related Issues
- Issue 2: Implement SM-2 Spaced Repetition Algorithm

** TODO [#A] Issue 34: Comprehensive Deck Hierarchy Operation Testing
:PROPERTIES:
:EFFORT:   12:00
:END:

*** User Story
As a GoCard developer,
I need thorough tests for deck hierarchy operations,
So that I can be confident that deck organization works correctly and maintains data integrity.

*** Details and Assumptions
- Deck hierarchy maps to directory structure
- Operations include creating, moving, renaming, and deleting decks
- Card operations across deck boundaries need testing
- Statistics calculations for nested decks should be verified

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given a complex deck hierarchy
When a deck is moved from one parent to another
Then all cards should maintain correct associations

Given a deck with subdecks
When statistics are calculated
Then they should correctly aggregate data from all levels

Given operations that modify the deck hierarchy
When they are performed concurrently
Then data integrity should be maintained

Given operations on decks
When path manipulations are involved
Then they should work correctly across platforms
#+END_SRC

*** Implementation Notes
- Create test fixtures for standard deck hierarchies
- Test cross-platform path handling
- Implement concurrency tests for deck operations
- Test error conditions thoroughly

*** Related Issues
- Issue 15: Implement Deck Organization through Directory Structure

** TODO [#B] Issue 35: Configuration Management Testing
:PROPERTIES:
:EFFORT:   8:00
:END:

*** User Story
As a GoCard developer,
I need thorough tests for the configuration system,
So that I can be confident it works correctly across platforms and with various user configurations.

*** Details and Assumptions
- Configuration is loaded from YAML files
- Path expansion (~/ for home directory) needs cross-platform testing
- Validation of configuration values should be tested
- Default application needs verification

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given various configuration scenarios
When the application loads
Then it should correctly read and apply configuration values

Given an invalid configuration
When the application loads
Then it should provide helpful error messages and fall back to defaults

Given platform-specific paths
When they are processed
Then they should be handled correctly for the current platform

Given missing configuration values
When the application loads
Then sensible defaults should be applied
#+END_SRC

*** Implementation Notes
- Create test fixtures with various configuration scenarios
- Mock filesystem for configuration file testing
- Test platform-specific path handling
- Test validation logic thoroughly

*** Related Issues
- Issue 11: Configuration File Management

** TODO [#B] Issue 36: Card Operations and Metadata Handling Tests
:PROPERTIES:
:EFFORT:   12:00
:END:

*** User Story
As a GoCard developer,
I need thorough tests for card operations and metadata handling,
So that I can be confident that card data is processed correctly and maintains integrity.

*** Details and Assumptions
- Cards are stored as Markdown files with YAML frontmatter
- Operations include creating, modifying, and deleting cards
- Metadata updates occur during reviews
- Frontmatter parsing needs to be robust

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given various card operations
When they are performed
Then the data should be correctly persisted and loaded

Given card metadata
When it is updated during reviews
Then the changes should be correctly saved to the frontmatter

Given malformed frontmatter
When a card is loaded
Then the application should handle errors gracefully

Given concurrent card operations
When they are performed
Then data integrity should be maintained
#+END_SRC

*** Implementation Notes
- Create test fixtures with various card scenarios
- Test frontmatter parsing edge cases
- Implement concurrency tests for card operations
- Test error conditions thoroughly

*** Related Issues
- Issue 1: File-Based Storage Implementation
- Issue 13: Convert to Goldmark for Markdown Processing

** TODO [#B] Issue 37: File Watching and Event Handling Tests
:PROPERTIES:
:EFFORT:   10:00
:END:

*** User Story
As a GoCard developer,
I need thorough tests for file watching and event handling,
So that I can be confident that changes made outside the application are correctly synchronized.

*** Details and Assumptions
- File watching uses fsnotify
- Events include creation, modification, deletion, and renaming
- Recursive directory watching needs testing
- Event debouncing should be verified

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given various filesystem events
When they occur
Then the application should correctly detect and handle them

Given concurrent filesystem events
When they occur rapidly
Then the application should handle them correctly with appropriate debouncing

Given nested directory structures
When events occur at any level
Then they should be correctly detected and processed

Given temporary files created by editors
When they appear in watched directories
Then they should be handled appropriately
#+END_SRC

*** Implementation Notes
- Mock filesystem events for deterministic testing
- Test various event sequences and edge cases
- Verify recursive directory watching
- Test event debouncing logic

*** Related Issues
- Issue 14: Implement Real-time File Watching with fsnotify

** TODO [#C] Issue 38: UI Component Testing Framework
:PROPERTIES:
:EFFORT:   16:00
:END:

*** User Story
As a GoCard developer,
I need a framework for testing UI components,
So that I can verify that the user interface behaves correctly and renders properly.

*** Details and Assumptions
- UI uses Bubble Tea for terminal UI
- Testing needs to cover model updates, view rendering, and input handling
- Different views (deck browser, review, etc.) need testing
- State transitions between views should be verified

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given a testing framework for UI components
When tests are run
Then they should verify that UI models update correctly

Given various user inputs
When they are processed by the UI
Then the application should respond correctly

Given state transitions between views
When they occur
Then the application should maintain correct state

Given different terminal sizes
When the UI renders
Then it should adapt correctly
#+END_SRC

*** Implementation Notes
- Create test harnesses for Bubble Tea models
- Mock terminal IO for testing
- Implement helpers for simulating user input
- Test viewport calculations and rendering

*** Related Issues
- Issue 3: Basic Card Navigation and Review Interface

** TODO [#B] Issue 39: Coverage Reporting and Visualization Improvements
:PROPERTIES:
:EFFORT:   6:00
:END:

*** User Story
As a GoCard developer,
I need improved test coverage reporting and visualization,
So that I can identify areas needing improved test coverage and track progress over time.

*** Details and Assumptions
- Basic coverage scripts exist
- We need per-package coverage breakdowns
- Visual representation would aid understanding
- Coverage trends should be tracked over time

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given the test suite
When coverage is measured
Then detailed per-package reports should be generated

Given coverage data
When it is processed
Then visual representations should be created

Given coverage over time
When new tests are added
Then trends should be tracked and visualized

Given the CI pipeline
When tests are run
Then coverage reporting should be integrated
#+END_SRC

*** Implementation Notes
- Enhance existing coverage scripts
- Implement visualization using go-cover-treemap
- Create a system for tracking coverage trends
- Integrate with CI pipeline

*** Related Issues
None

** TODO [#B] Issue 40: Test Data Generation and Fixtures
:PROPERTIES:
:EFFORT:   8:00
:END:

*** User Story
As a GoCard developer,
I need standardized test data and generators,
So that I can create reliable, comprehensive tests for all aspects of the application.

*** Details and Assumptions
- Tests need predictable, standard data
- Random data is useful for edge case testing
- Fixtures should cover common scenarios
- Generators should produce valid, realistic data

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given the test suite
When tests are run
Then they should use standardized test data

Given test fixtures
When they are used in tests
Then they should cover common scenarios

Given data generators
When they are used
Then they should produce valid, realistic data

Given the test environment
When tests are run
Then cleanup should be automatic
#+END_SRC

*** Implementation Notes
- Create standard test fixtures for cards and decks
- Implement generators for random valid data
- Ensure reproducibility of test data
- Automate cleanup after tests

*** Related Issues
None

** TODO [#B] Issue 41: Test Helpers and Assertion Utilities
:PROPERTIES:
:EFFORT:   8:00
:END:

*** User Story
As a GoCard developer,
I need test helpers and assertion utilities,
So that I can write clean, maintainable tests more efficiently.

*** Details and Assumptions
- Common operations should have helpers
- Domain-specific assertions would improve test readability
- Builders for test objects would streamline test setup
- Helpers should support table-driven tests

*** Acceptance Criteria
#+BEGIN_SRC gherkin
Given test helpers for common operations
When they are used in tests
Then they should simplify test setup and execution

Given domain-specific assertions
When tests verify behavior
Then assertions should be clear and meaningful

Given test object builders
When tests require complex objects
Then builders should simplify their creation

Given the test suite
When helpers are used throughout
Then tests should be more readable and maintainable
#+END_SRC

*** Implementation Notes
- Create helpers for common setup/teardown operations
- Implement domain-specific assertion functions
- Create builders for complex test objects
- Document helper functions thoroughly

*** Related Issues
None
